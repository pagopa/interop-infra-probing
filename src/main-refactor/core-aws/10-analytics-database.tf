resource "aws_security_group" "probing_analytics" {
  name        = format("timestream/%s-analytics-%s", local.project, var.env)
  description = "SG for Timestream for InfluxDB instances"

  vpc_id = data.aws_vpc.probing.id

  ingress {
    description = "Clients inside VPC"
    from_port   = 0
    to_port     = 65535
    protocol    = "tcp"
    security_groups = [
      module.eks.cluster_primary_security_group_id,
      data.aws_security_group.vpn_clients.id
    ]
  }
}

locals {
  timestream_instance_name = format("%s-analytics-%s", local.project, var.env)
  timestream_organization  = local.timestream_instance_name #TOCHECK
  bucket_prefix_name       = "probing-telemetry"
}

resource "random_password" "probing_analytics_admin" {
  length  = 16
  special = false
  upper   = true
  lower   = true
  numeric = true
}

resource "aws_secretsmanager_secret" "probing_analytics_admin" {
  name                    = "timestream/${local.timestream_instance_name}/users/admin"
  recovery_window_in_days = 0
}

resource "aws_secretsmanager_secret_version" "probing_analytics_admin" {
  secret_id = aws_secretsmanager_secret.probing_analytics_admin.id

  secret_string = jsonencode({
    timestream_instance     = local.timestream_instance_name
    timestream_organization = local.timestream_organization
    username                = "admin"
    password                = random_password.probing_analytics_admin.result
    token                   = "" # Must be generated via Influx UI from AWS console or via influx CLI
  })
}

resource "aws_timestreaminfluxdb_db_instance" "probing_analytics" {
  name         = local.timestream_instance_name
  organization = local.timestream_organization

  bucket = format("%s-%s", local.bucket_prefix_name, var.env)

  allocated_storage = 20
  db_instance_type  = "db.influx.medium"
  deployment_type   = "WITH_MULTIAZ_STANDBY"

  username = jsondecode(aws_secretsmanager_secret_version.probing_analytics_admin.secret_string)["username"]
  password = jsondecode(aws_secretsmanager_secret_version.probing_analytics_admin.secret_string)["password"]

  vpc_subnet_ids         = data.aws_subnets.timestream_probing_analytics_store.ids
  vpc_security_group_ids = [aws_security_group.probing_analytics.id]
}

# Retrieve the admin token (that has been automatically generated by the aws_timestreaminfluxdb_db_instance resource) and store it in the self-managed SecretsManager secret
resource "terraform_data" "probing_analytics_store_admin_token" {
  depends_on = [aws_timestreaminfluxdb_db_instance.probing_analytics, aws_secretsmanager_secret_version.probing_analytics_admin]

  triggers_replace = [
    aws_timestreaminfluxdb_db_instance.probing_analytics,
    aws_secretsmanager_secret.probing_analytics_admin
  ]

  provisioner "local-exec" {
    environment = {
      INSTANCE_HOST                = format("https://%s:%s", aws_timestreaminfluxdb_db_instance.probing_analytics.endpoint, aws_timestreaminfluxdb_db_instance.probing_analytics.port)
      ORGANIZATION                 = aws_timestreaminfluxdb_db_instance.probing_analytics.organization
      ADMIN_CREDENTIALS_SECRET_ARN = aws_secretsmanager_secret.probing_analytics_admin.arn
    }

    command = <<EOT
      #!/bin/bash
      set -euo pipefail

      secret_json=$(aws secretsmanager get-secret-value --secret-id "$ADMIN_CREDENTIALS_SECRET_ARN" --query SecretString --output text)
      
      ADMIN_USERNAME=$(echo "$secret_json" | jq -r '.username')
      ADMIN_PASSWORD=$(echo "$secret_json" | jq -r '.password')

      influx config create --config-name admin-config --host-url "$INSTANCE_HOST" --org "$ORGANIZATION" -p "$ADMIN_USERNAME":"$ADMIN_PASSWORD" --active

      echo "Retrieving the admin token..."
      
      ADMIN_TOKEN=$(influx auth list --user admin --json | jq -r '.[0].token')

      echo "Saving token into Secrets Manager..."
      aws secretsmanager put-secret-value --secret-id "$ADMIN_CREDENTIALS_SECRET_ARN" \
        --secret-string "$(echo "$secret_json" | jq --arg token "$ADMIN_TOKEN" '. + {token: $token}')"
    EOT
  }
}

locals {
  influxdb_buckets_to_create = [
    for stage in var.stages_to_provision : format("%s-%s", local.bucket_prefix_name, stage) if stage != var.env # Exclude the current environment from the list of buckets to create
  ]
}

# Create a bucket in the InfluxDB instance for each stage (excluding the one equals to the var.env value because it is already created by the aws_timestreaminfluxdb_db_instance.probing_analytics resource)
resource "terraform_data" "probing_analytics_create_bucket" {
  depends_on = [aws_timestreaminfluxdb_db_instance.probing_analytics, aws_secretsmanager_secret_version.probing_analytics_admin, terraform_data.probing_analytics_store_admin_token]

  for_each = toset(local.influxdb_buckets_to_create)

  triggers_replace = {
    instance_name     = aws_timestreaminfluxdb_db_instance.probing_analytics.name,
    organization_name = aws_timestreaminfluxdb_db_instance.probing_analytics.organization
  }

  provisioner "local-exec" {
    environment = {
      INSTANCE_HOST                = format("https://%s:%s", aws_timestreaminfluxdb_db_instance.probing_analytics.endpoint, aws_timestreaminfluxdb_db_instance.probing_analytics.port)
      ORGANIZATION                 = aws_timestreaminfluxdb_db_instance.probing_analytics.organization
      BUCKET_TO_CREATE             = each.key
      BUCKET_RETENTION             = var.probing_analytics_buckets_retention
      ADMIN_CREDENTIALS_SECRET_ARN = aws_secretsmanager_secret.probing_analytics_admin.arn
    }

    command = <<EOT
      #!/bin/bash
      set -euo pipefail
      
      secret_json=$(aws secretsmanager get-secret-value --secret-id $ADMIN_CREDENTIALS_SECRET_ARN --query SecretString --output text)

      ADMIN_TOKEN=$(echo $secret_json | jq -r '.token')
      if [ -z "$ADMIN_TOKEN" ]; then
        echo "The admin token has not been set in the secret. The InfluxDB buckets creation will be skipped."
        exit 1
      fi

      echo "Checking if bucket '$BUCKET_TO_CREATE' exists..."
      BUCKET_ID=$(influx bucket list --host "$INSTANCE_HOST" --org "$ORGANIZATION" --token "$ADMIN_TOKEN" --json | jq -r --arg name "$BUCKET_TO_CREATE" '.[] | select(.name == $name) | .id')

      if [ -z "$BUCKET_ID" ]; then
        echo "Creating bucket '$BUCKET_TO_CREATE' in organization '$ORGANIZATION'..."
        influx bucket create --host "$INSTANCE_HOST" --org "$ORGANIZATION" --name "$BUCKET_TO_CREATE" --token "$ADMIN_TOKEN" --retention "$BUCKET_RETENTION"
      else
        echo "Bucket '$BUCKET_TO_CREATE' already exists."
        exit 1
      fi
    EOT
  }
}

# Update the existing buckets in case their retention change
resource "terraform_data" "probing_analytics_update_bucket" {
  depends_on = [aws_timestreaminfluxdb_db_instance.probing_analytics, aws_secretsmanager_secret_version.probing_analytics_admin, terraform_data.probing_analytics_store_admin_token, terraform_data.probing_analytics_create_bucket]

  for_each = toset(local.influxdb_buckets_to_create)

  triggers_replace = {
    bucket_retention = var.probing_analytics_buckets_retention
  }

  provisioner "local-exec" {
    environment = {
      INSTANCE_HOST                = format("https://%s:%s", aws_timestreaminfluxdb_db_instance.probing_analytics.endpoint, aws_timestreaminfluxdb_db_instance.probing_analytics.port)
      ORGANIZATION                 = aws_timestreaminfluxdb_db_instance.probing_analytics.organization
      BUCKET_NAME                  = each.key
      BUCKET_RETENTION             = self.triggers_replace.bucket_retention
      ADMIN_CREDENTIALS_SECRET_ARN = aws_secretsmanager_secret.probing_analytics_admin.arn
    }

    command = <<EOT
      #!/bin/bash
      set -euo pipefail
      
      secret_json=$(aws secretsmanager get-secret-value --secret-id $ADMIN_CREDENTIALS_SECRET_ARN --query SecretString --output text)

      ADMIN_TOKEN=$(echo $secret_json | jq -r '.token')
      if [ -z "$ADMIN_TOKEN" ]; then
        echo "The admin token has not been set in the secret. The InfluxDB buckets creation will be skipped."
        exit 1
      fi

      echo "Checking if bucket '$BUCKET_NAME' exists..."
      BUCKET_ID=$(influx bucket list --host "$INSTANCE_HOST" --org "$ORGANIZATION" --token "$ADMIN_TOKEN" --json | jq -r --arg name "$BUCKET_NAME" '.[] | select(.name == $name) | .id')

      if [ -z "$BUCKET_ID" ]; then
        echo "Bucket '$BUCKET_NAME' doesn't exist."
        exit 1
      else

        CURRENT_BUCKET_RETENTION=$(influx bucket list --host "$INSTANCE_HOST" --org "$ORGANIZATION" --token "$ADMIN_TOKEN" --id "$BUCKET_ID" --json | jq -r '.[0].retentionRules[0].everySeconds // 0')
        
        DESIRED_RETENTION_SECONDS=$(echo "$BUCKET_RETENTION" | sed -E 's/([0-9]+)s/\1/; s/([0-9]+)m/\1*60/; s/([0-9]+)h/\1*3600/; s/([0-9]+)d/\1*86400/' | bc)

        if [ "$CURRENT_BUCKET_RETENTION" != "$DESIRED_RETENTION_SECONDS" ]; then
          echo "Updating bucket '$BUCKET_NAME'..."
          
          if [ "$DESIRED_RETENTION_SECONDS" -eq 0 ]; then
            SHARD_GROUP_DURATION_SECONDS=604800
          else
            SHARD_GROUP_DURATION_SECONDS=$(( DESIRED_RETENTION_SECONDS / 2 ))
          fi

          influx bucket update --host "$INSTANCE_HOST" --id "$BUCKET_ID" --token "$ADMIN_TOKEN" --retention "$BUCKET_RETENTION" --shard-group-duration "$SHARD_GROUP_DURATION_SECONDS"s
        else
          echo "No need to update the bucket '$BUCKET_NAME'."
        fi

      fi
    EOT
  }
}